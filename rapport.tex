\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc} % un package
\usepackage[francais]{babel} %active le mode francais
\usepackage[top=2cm , bottom=2cm , left=2cm , right=2cm]{geometry} %propriétés de notre page
\usepackage{amsmath} %liste de symboles et applications mathématiques
\usepackage{color} %Permet d'utiliser la couleur dans nos documents
\usepackage{listings} %Paquet de coloration syntaxique (langages)
\usepackage{hyperref} % Créer des liens et des signets 
\usepackage[babel=true]{csquotes} %permet les quotations (guillemets)
\usepackage{graphicx} %Importation d'image
\lstset{language=C}
% Informations du rapport
\title {Rapport \\ Travaux Pratiques Etudes des Algorithmes \\ Évaluation dynamique de programme}
\author {Quentin Tonneau - Adrien Lardenois}
\date{}
%Propriétés des liens
\hypersetup{
colorlinks=true, %colorise les liens  
urlcolor= blue, %couleur des hyperliens 
linkcolor= blue,%couleur des liens internes 
} 

\begin{document}
	\maketitle %insère l'en-tête du rapport
	\tableofcontents %insère la table des matières ATTENTION : Compiler deux fois en cas de changements
	\newpage % Nouvelle page
	
	
	\section{Introduction}
	Le but de ce projet est de fournir un logiciel capable de donner et d'évaluer le graphe de contrôle d'un programme écrit dans un pseudo langage ``simple''. Pour cela on met en place une interface très simple : on affiche un menu à choix multiple numéroté, le numéro choisi par l'utilisateur passe dans un ``switch'' qui exécute les différentes actions correspondantes. On utilise un flag pour vérifier qu'un fichier est bien en cours d'analyse pour éviter les erreurs.

	Pour la création du graphe en lui-même, nous avons  choisi une liste chaînée. Chaque cellule contient :
	\begin{itemize}
		\item un sommet numéroté
		\item une étiquette (qui peut être vide)
		\item la liste chaînée des arêtes qui partent de ce sommet
		\item le lien vers la cellule suivante
	\end{itemize}
	Une cellule d'arête contient : 
	\begin{itemize}
		\item le numéro du sommet d'arrivée 
		\item une étiquette (normalement l'instruction permettant de passer par l'arête)
		\item la cellule arête suivante
	\end{itemize}
	
	L'utilisation d'une liste chaînée de liste chaînée permet de simplifier la manipulation de la mémoire tout en gardant une forte cohérence des données, chaque liste d'arêtes étant attachée à son sommet d'origine. On dispose de fonctions pour ajouter des sommets et des arêtes, rechercher un sommet dans la liste, et enfin une fonction d'affichage du graphe.
	\subsection{Les fonctions d'ajout}
		L'ajout d'un sommet prend simplement le numéro et l'étiquette du sommet à créer ainsi que la liste à laquelle l'ajouter. On crée alors une nouvelle cellule et on l'ajoute en fin de liste, sauf pour une liste vide où elle devient la seule et unique cellule de la liste. En effet, l'utilisation par notre programme fait que jamais on ne créera deux sommets de même numéro et que les sommets sont créés en suivant une incrémentation régulière. Ainsi la liste proposera les sommets dans l'ordre de numérotation\footnote{qui pourra être différent de l'ordre d'exécution, surtout dans les programmes contenant des conditionnelles.}

		L'ajout d'une arête passe par une fonction intermédiaire. En apparence, on appelle \textbf{ajouter\_arête} avec pour arguments l'étiquette, le sommet de départ, le sommet d'arrivée et la liste de sommets. En fait, cette fonction n'est qu'un ``masque'' qui appelle \textbf{ajouter\_arête\_l} avec comme arguments : 
		\begin{itemize}
			\item l'étiquette
			\item la cellule du sommet de départ, donnée par \textit{recherche\_sommet(sommet\_d, liste)}
			\item le sommet d'arrivée
		\end{itemize}
		L'ajout se fait ensuite de façon standard, on crée une nouvelle cellule arête et on l'ajoute en tête de la liste d'arête.
	\subsection{Les fonctions de recherche et d'affichage}
		Ces deux fonctions reposent sur le même principe, on crée un clone de la liste que l'on parcours ensuite.

 Dans le cas de la recherche, on s'arrête dès que l'on trouve le sommet recherché ou que l'on est arrivé à la fin de la liste. Si on a effectivement trouvé on renvoie la cellule du sommet, sinon on ajoute le sommet à la liste et on rappelle la fonction à nouveau. Une utilisation normale n'appellera jamais de sommet inconnu mais nous avons fais ce choix afin d'éviter un blocage du programme en cas d'erreur.

	Dans le cas de l'affichage, le parcours se fait systématiquement jusqu'à la fin. Pour chaque sommet, on affiche sont numéro et son étiquette, puis on parcours sa liste d'arête de la même manière que la liste de sommet. A chaque arête, on affiche l'étiquette et le sommet d'arrivée, puis on passe à l'arête suivante. Quand la liste est finie, on passe au sommet suivant.

	\section{Ouverture et parsing}
		\textit{On considère dans la suite de ce rapport que le fichier d'entrée contient uniquement le programme, correctement syntaxifié.}
		
		Le code d'ouverture et de parsing du fichier se trouve dans les fichiers ``parser.c'' et ``parser.h''.
		\subsection{Ouverture du fichier}
		Le code permettant la lecture du fichier est simple, et commun à la plupart des applications réalisées en C. On note au passage que l'ouverture se fait en mode ``lecture'' uniquement.
		\begin{lstlisting}
FILE* fichier=NULL;
fichier=fopen(nomfichier,"r");
if(fichier==NULL)
{
	return 0; //on quitte le programme avec une erreur
}
		\end{lstlisting}
		\subsection{Parsing du fichier}
		L'algorithme repose sur une série de variable définies de la façon suivante :
		\begin{itemize}
		\item motlut : variable contenant le mot en cour de traitement (max. 50 caractères)
		\item instruction : concaténation des mots lus jusqu'à ``;''
		\item sommetactuel : numéro du dernier sommet créé
		\item nbsommet : nombre de sommet jusqu'à présent créés
		\end{itemize}
		Le parsing s'effectue à l'aide de la fonction fscanf, qui récupère un à un les mots contenus dans le fichier.
		\subsubsection{Cas général}
		Dans un fonctionnement général, c'est à dire un enchaînement d'instructions sans conditionnelle, l'algorithme concatène les mots lus jusqu'au symbole ';', puis crée une arête à l'aide de \\\textbf{ajouter\_sommet(nbsommet+1,graphe,"")} (sommet d'arrivée) puis \\\textbf{ajouter\_arête(instruction,sommetactuel,nbsommet,graphe)} dans laquelle nbsommet correspond au numéro du sommet tout juste créé.
		\subsubsection{Traitement des conditionnelles}
		Lorsque le programme rencontre le mot \textbf{Si}, il concatène l'ensemble des informations suivantes jusqu'au mot \textbf{Alors} dans une variable, crée un sommet portant pour étiquette la chaîne précédemment générée, et le relie au graphique à l'aide d'une branche vierge.
		
		Il est important de décrire la manière dont les conditionnelles sont traitées :\\
		L'algorithme possède un tableau d'entiers dans lequel on peut placer un numéro de sommet dont on nécessite de conserver sa place. Lorsque l'on rencontre un ``Si'' ou un ``Tantque'', on sauvegarde le sommet de condition dans la première case vide du tableau, et l'on crée la branche \textit{vraie}. Lorsque l'on rencontre un ``Sinon'', on remonte au sommet de conditionnelle, on stocke à la place le sommet de fin de branche gauche, et on entame la poursuite du chemin droit. Arrivé à un ``Fsi'', on crée un chemin depuis l'emplacement sauvegardé vers un nouveau sommet, un autre chemin depuis notre emplacement vers ce même sommet, et on continue le parsing. La gestion du Tantque est similaire, à l'inversion près des flèches (arrivé au Ftantque)(on revient vers le sommet sauvegardé et non le sommet créé).\\
		 Le schéma suivant montre comment sont traitées les conditionnelles :
		\begin{center}\includegraphics[width=17cm,height=7cm]{dessin.pdf}\end{center}
	On remarque que quelque soit le type de conditionnelle, on utilise toujours une seule case de notre \textit{Tableau de sauvegarde}. En cas d'imbrication de conditionnelles, le programme utilisera les cases suivantes, et les détruiras à la fin des traitements. Ainsi, en limitant à 50 la taille de notre tableau, nous limitons le nombre d'imbrication \textbf{maximum} à 50, ce qui est déjà une limite très grande. Un simple jeu de ré-allocation permettrait en outre de fournir une limite quasi infinie.
	\section{Analyse du graphe}
	\section{Pour aller plus loin}
	\section{Conclusion}

\end{document}
